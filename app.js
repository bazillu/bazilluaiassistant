// app.js - Main application logic for Spur AI document.addEventListener('DOMContentLoaded', () => { // DOM Elements const chatMessages = document.getElementById('chat-messages'); const messageInput = document.getElementById('message-input'); const sendMessageBtn = document.getElementById('send-message-btn'); const newChatBtn = document.getElementById('new-chat-btn'); const prevChatsBtn = document.getElementById('prev-chats-btn'); const newCanvasBtn = document.getElementById('new-canvas-btn'); const askQuestionBtn = document.getElementById('ask-question-btn'); const settingsBtn = document.getElementById('settings-btn'); const trainingBtn = document.getElementById('training-btn'); const chatInterface = document.getElementById('chat-interface'); const canvasArea = document.getElementById('canvas-area'); const trainingArea = document.getElementById('training-area'); const closeCanvasBtn = document.getElementById('close-canvas-btn'); const closeTrainingBtn = document.getElementById('close-training-btn'); // Modal Elements const questionModal = document.getElementById('question-modal'); const questionInput = document.getElementById('question-input'); const submitQuestionBtn = document.getElementById('submit-question-btn'); const cancelQuestionBtn = document.getElementById('cancel-question-btn'); const settingsModal = document.getElementById('settings-modal'); const closeSettingsBtn = document.getElementById('close-settings-btn'); const saveSettingsBtn = document.getElementById('save-settings-btn'); const prevChatsModal = document.getElementById('prev-chats-modal'); const prevChatsList = document.getElementById('prev-chats-list'); const closePrevChatsBtn = document.getElementById('close-prev-chats-btn'); // Training Elements const knowledgeCategory = document.getElementById('knowledge-category'); const knowledgeKey = document.getElementById('knowledge-key'); const knowledgeSynonyms = document.getElementById('knowledge-synonyms'); const knowledgeContent = document.getElementById('knowledge-content'); const addKnowledgeBtn = document.getElementById('add-knowledge-btn'); const viewCategory = document.getElementById('view-category'); const knowledgeList = document.getElementById('knowledge-list'); const keyInputContainer = document.getElementById('key-input-container'); const synonymsContainer = document.getElementById('synonyms-container'); // Current chat state let currentChatId = null; let currentChatMessages = []; // Initialize with a greeting setTimeout(() => { const greeting = getRandomItem(spurAIData.greetings); addAIMessage(greeting); currentChatMessages.push({ type: 'ai', content: greeting, timestamp: new Date().toISOString() }); }, 500); // Event Listeners sendMessageBtn.addEventListener('click', sendMessage); messageInput.addEventListener('keypress', (e) => { if (e.key === 'Enter') sendMessage(); }); newChatBtn.addEventListener('click', startNewChat); prevChatsBtn.addEventListener('click', loadPreviousChats); newCanvasBtn.addEventListener('click', toggleCanvas); askQuestionBtn.addEventListener('click', () => toggleModal(questionModal)); settingsBtn.addEventListener('click', () => toggleModal(settingsModal)); trainingBtn.addEventListener('click', toggleTraining); closeCanvasBtn.addEventListener('click', toggleCanvas); closeTrainingBtn.addEventListener('click', toggleTraining); cancelQuestionBtn.addEventListener('click', () => toggleModal(questionModal)); submitQuestionBtn.addEventListener('click', submitQuestion); closeSettingsBtn.addEventListener('click', () => toggleModal(settingsModal)); saveSettingsBtn.addEventListener('click', saveSettings); closePrevChatsBtn.addEventListener('click', () => toggleModal(prevChatsModal)); // Training mode event listeners addKnowledgeBtn.addEventListener('click', addKnowledge); viewCategory.addEventListener('change', displayKnowledgeBase); knowledgeCategory.addEventListener('change', handleCategoryChange); // Initialize knowledge list displayKnowledgeBase(); // Functions function sendMessage() { const message = messageInput.value.trim(); if (message === '') return; addUserMessage(message); messageInput.value = ''; // Add to current chat messages currentChatMessages.push({ type: 'user', content: message, timestamp: new Date().toISOString() }); // Simulate AI thinking setTimeout(() => { showTypingIndicator(); setTimeout(() => { removeTypingIndicator(); const response = respondToMessage(message); addAIMessage(response); // Add to current chat messages currentChatMessages.push({ type: 'ai', content: response, timestamp: new Date().toISOString() }); // Save chat if this is the first exchange if (!currentChatId && currentChatMessages.length >= 3) { // Extract a title from the first user message const title = extractChatTitle(currentChatMessages[1].content); currentChatId = saveChatToHistory(title, currentChatMessages); } else if (currentChatId) { // Update existing chat const chatIndex = spurAIData.chatHistory.findIndex(chat => chat.id === currentChatId); if (chatIndex !== -1) { spurAIData.chatHistory[chatIndex].messages = currentChatMessages; saveSpurData(); } } }, getResponseDelay()); }, 300); } function addUserMessage(message) { const messageElement = document.createElement('div'); messageElement.className = 'chat-message user-message'; messageElement.innerHTML = `<p>${message}</p>`; chatMessages.appendChild(messageElement); scrollToBottom(); } function addAIMessage(message) { const messageElement = document.createElement('div'); messageElement.className = 'chat-message ai-message'; messageElement.innerHTML = ` <div class="flex items-start"> <div class="flex-shrink-0 mr-3"> <div class="w-8 h-8 rounded-full bg-gradient-to-br from-red-500 via-green-500 to-blue-500 flex items-center justify-center text-white font-bold"> S </div> </div> <div> <p>${message}</p> </div> </div> `; chatMessages.appendChild(messageElement); scrollToBottom(); } function showTypingIndicator() { const indicatorElement = document.createElement('div'); indicatorElement.id = 'typing-indicator'; indicatorElement.className = 'chat-message ai-message'; indicatorElement.innerHTML = ` <div class="flex items-start"> <div class="flex-shrink-0 mr-3"> <div class="w-8 h-8 rounded-full bg-gradient-to-br from-red-500 via-green-500 to-blue-500 flex items-center justify-center text-white font-bold"> S </div> </div> <div class="typing-indicator"> <span></span> <span></span> <span></span> </div> </div> `; chatMessages.appendChild(indicatorElement); scrollToBottom(); } function removeTypingIndicator() { const indicator = document.getElementById('typing-indicator'); if (indicator) { indicator.remove(); } } function respondToMessage(message) { const lowerMessage = message.toLowerCase(); // Check for topic matches first (most specific) const topicMatch = findTopicMatch(lowerMessage); if (topicMatch) { return topicMatch; } // Check for concept definitions for (const concept in spurAIData.concepts) { if (messageContainsKeyword(lowerMessage, concept)) { return spurAIData.concepts[concept]; } } // Check for facts for (const fact in spurAIData.facts) { if (messageContainsKeyword(lowerMessage, fact)) { return spurAIData.facts[fact]; } } // Check for common responses for (const key in spurAIData.responses) { if (messageContainsKeyword(lowerMessage, key)) { return getRandomItem(spurAIData.responses[key]); } } // Use fallback if no match found return getRandomItem(spurAIData.fallback); } // Improved matching function that checks for synonyms and variations function findTopicMatch(message) { // First check direct topic matches for (const topic in spurAIData.topics) { if (messageContainsKeyword(message, topic)) { return spurAIData.topics[topic].content; } // Check synonyms for this topic const synonyms = spurAIData.topics[topic].synonyms || []; for (const synonym of synonyms) { if (messageContainsKeyword(message, synonym)) { return spurAIData.topics[topic].content; } } } // Check for "what is X" or "define X" patterns const definePatterns = ['what is', 'define', 'meaning of', 'definition of', 'explain', 'tell me about']; for (const pattern of definePatterns) { if (message.includes(pattern)) { const remainder = message.split(pattern)[1]?.trim(); if (remainder) { // Check if the remainder matches any topic for (const topic in spurAIData.topics) { if (remainder === topic || remainder.includes(topic)) { return spurAIData.topics[topic].content; } } } } } return null; } // Check if a message contains a keyword or its synonyms function messageContainsKeyword(message, keyword) { // Direct match if (message.includes(keyword)) { return true; } // Check for synonyms const synonymsForKeyword = []; // Add synonyms from the general synonyms dictionary for (const term in spurAIData.synonyms) { if (keyword.includes(term)) { synonymsForKeyword.push(...spurAIData.synonyms[term]); } } // Check if any synonym is in the message for (const synonym of synonymsForKeyword) { if (message.includes(synonym)) { return true; } } return false; } function startNewChat() { chatMessages.innerHTML = ''; currentChatId = null; currentChatMessages = []; const greeting = getRandomItem(spurAIData.greetings); addAIMessage(greeting); currentChatMessages.push({ type: 'ai', content: greeting, timestamp: new Date().toISOString() }); } function toggleCanvas() { if (canvasArea.classList.contains('hidden')) { chatInterface.classList.add('hidden'); trainingArea.classList.add('hidden'); canvasArea.classList.remove('hidden'); } else { canvasArea.classList.add('hidden'); chatInterface.classList.remove('hidden'); } } function toggleTraining() { if (trainingArea.classList.contains('hidden')) { chatInterface.classList.add('hidden'); canvasArea.classList.add('hidden'); trainingArea.classList.remove('hidden'); displayKnowledgeBase(); // Refresh the knowledge display } else { trainingArea.classList.add('hidden'); chatInterface.classList.remove('hidden'); } } function submitQuestion() { const question = questionInput.value.trim(); if (question === '') return; toggleModal(questionModal); addUserMessage(question); questionInput.value = ''; // Add to current chat messages currentChatMessages.push({ type: 'user', content: question, timestamp: new Date().toISOString() }); // Simulate AI thinking setTimeout(() => { showTypingIndicator(); setTimeout(() => { removeTypingIndicator(); const response = respondToMessage(question); addAIMessage(response); // Add to current chat messages currentChatMessages.push({ type: 'ai', content: response, timestamp: new Date().toISOString() }); // Save chat if this is the first exchange if (!currentChatId && currentChatMessages.length >= 3) { const title = extractChatTitle(question); currentChatId = saveChatToHistory(title, currentChatMessages); } else if (currentChatId) { // Update existing chat const chatIndex = spurAIData.chatHistory.findIndex(chat => chat.id === currentChatId); if (chatIndex !== -1) { spurAIData.chatHistory[chatIndex].messages = currentChatMessages; saveSpurData(); } } }, getResponseDelay()); }, 300); } function saveSettings() { // In a real app, this would save the settings toggleModal(settingsModal); addAIMessage("Settings have been updated successfully!"); } function toggleModal(modal) { if (modal.classList.contains('hidden')) { modal.classList.remove('hidden'); } else { modal.classList.add('hidden'); } } function scrollToBottom() { chatInterface.scrollTop = chatInterface.scrollHeight; } function getRandomItem(array) { return array[Math.floor(Math.random() * array.length)]; } function getResponseDelay() { const speedSelect = document.getElementById('speed-select'); const speed = speedSelect ? speedSelect.value : 'medium'; switch (speed) { case 'fast': return 500; case 'slow': return 2000; default: return 1000; } } // Extract a title from the first user message function extractChatTitle(message) { // Limit to first 30 characters or first sentence const title = message.split('.')[0].trim(); return title.length > 30 ? title.substring(0, 27) + '...' : title; } // Load and display previous chats function loadPreviousChats() { prevChatsList.innerHTML = ''; if (spurAIData.chatHistory.length === 0) { prevChatsList.innerHTML = '<div class="p-3 text-gray-500">No previous chats found.</div>'; } else { spurAIData.chatHistory.forEach(chat => { const chatItem = document.createElement('div'); chatItem.className = 'p-3 border border-gray-200 rounded-md hover:bg-gray-50 cursor-pointer'; // Format the date const date = new Date(chat.timestamp); const formattedDate = date.toLocaleDateString() + ', ' + date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }); chatItem.innerHTML = ` <div class="font-medium">${chat.title}</div> <div class="text-sm text-gray-500">${formattedDate}</div> `; chatItem.addEventListener('click', () => { loadChat(chat.id); toggleModal(prevChatsModal); }); prevChatsList.appendChild(chatItem); }); } toggleModal(prevChatsModal); } // Load a specific chat function loadChat(chatId) { const chat = getChatFromHistory(chatId); if (!chat) return; // Clear current chat chatMessages.innerHTML = ''; currentChatId = chatId; currentChatMessages = [...chat.messages]; // Clone the messages array // Display messages chat.messages.forEach(msg => { if (msg.type === 'user') { addUserMessage(msg.content); } else if (msg.type === 'ai') { addAIMessage(msg.content); } }); } // Training functions function handleCategoryChange() { const category = knowledgeCategory.value; // Show/hide key input and synonyms based on category if (category === 'greetings' || category === 'fallback') { keyInputContainer.style.display = 'none'; synonymsContainer.style.display = 'none'; } else if (category === 'topics') { keyInputContainer.style.display = 'block'; synonymsContainer.style.display = 'block'; } else { keyInputContainer.style.display = 'block'; synonymsContainer.style.display = 'none'; } } function addKnowledge() { const category = knowledgeCategory.value; const key = knowledgeKey.value.trim().toLowerCase(); const synonyms = knowledgeSynonyms.value.trim(); const content = knowledgeContent.value.trim(); if (content === '') { alert('Please enter content for the knowledge item'); return; } // Add to the appropriate category switch (category) { case 'topics': if (key === '') { alert('Please enter a key/trigger for this topic'); return; } // Process synonyms const synonymsList = synonyms ? synonyms.split(',').map(s => s.trim().toLowerCase()).filter(s => s !== '') : []; // Create or update topic spurAIData.topics[key] = { synonyms: synonymsList, content: content }; break; case 'concepts': if (key === '') { alert('Please enter a key/trigger for this concept'); return; } spurAIData.concepts[key] = content; break; case 'facts': if (key === '') { alert('Please enter a key/trigger for this fact'); return; } spurAIData.facts[key] = content; break; case 'responses': if (key === '') { alert('Please enter a key/trigger for this response'); return; } if (!spurAIData.responses[key]) { spurAIData.responses[key] = []; } spurAIData.responses[key].push(content); break; case 'greetings': spurAIData.greetings.push(content); break; case 'fallback': spurAIData.fallback.push(content); break; } // Save to localStorage saveSpurData(); // Clear inputs knowledgeKey.value = ''; knowledgeSynonyms.value = ''; knowledgeContent.value = ''; // Refresh display displayKnowledgeBase(); // Confirmation message alert('Knowledge added successfully!'); } function displayKnowledgeBase() { const category = viewCategory.value; knowledgeList.innerHTML = ''; if (category === 'all' || category === 'topics') { displayTopicItems('Topics'); } if (category === 'all' || category === 'concepts') { displayCategoryItems('concepts', 'Concepts'); } if (category === 'all' || category === 'facts') { displayCategoryItems('facts', 'Facts'); } if (category === 'all' || category === 'responses') { displayCategoryItems('responses', 'Common Responses'); } if (category === 'all' || category === 'greetings') { displayArrayItems('greetings', 'Greetings'); } if (category === 'all' || category === 'fallback') { displayArrayItems('fallback', 'Fallback Responses'); } // Add click handlers for expanding/collapsing items document.querySelectorAll('.knowledge-item-header').forEach(header => { header.addEventListener('click', () => { const item = header.parentElement; item.classList.toggle('expanded'); }); }); // Add delete handlers document.querySelectorAll('.delete-knowledge-btn').forEach(btn => { btn.addEventListener('click', (e) => { e.stopPropagation(); deleteKnowledgeItem(btn.dataset.category, btn.dataset.key, btn.dataset.index); }); }); } function displayTopicItems(title) { const topics = spurAIData.topics; if (Object.keys(topics).length === 0) { return; } const categoryHeader = document.createElement('div'); categoryHeader.className = 'font-bold text-lg mt-4 mb-2'; categoryHeader.textContent = title; knowledgeList.appendChild(categoryHeader); for (const key in topics) { const itemDiv = document.createElement('div'); itemDiv.className = 'knowledge-item'; const topic = topics[key]; itemDiv.innerHTML = ` <div class="knowledge-item-header"> <div class="font-medium">${key}</div> <div class="flex items-center"> <button class="text-gray-500 hover:text-red-500 delete-knowledge-btn" data-category="topics" data-key="${key}"> <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor"> <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16" /> </svg> </button> </div> </div> <div class="knowledge-item-content"> <div class="mb-2"> <span class="font-medium">Synonyms:</span> ${topic.synonyms && topic.synonyms.length > 0 ? topic.synonyms.join(', ') : 'None'} </div> <div> <span class="font-medium">Content:</span> ${topic.content} </div> </div> `; knowledgeList.appendChild(itemDiv); } } function displayCategoryItems(category, title) { const categoryData = spurAIData[category]; if (Object.keys(categoryData).length === 0) { return; } const categoryHeader = document.createElement('div'); categoryHeader.className = 'font-bold text-lg mt-4 mb-2'; categoryHeader.textContent = title; knowledgeList.appendChild(categoryHeader); for (const key in categoryData) { const itemDiv = document.createElement('div'); itemDiv.className = 'knowledge-item'; const content = categoryData[key]; const isArray = Array.isArray(content); itemDiv.innerHTML = ` <div class="knowledge-item-header"> <div class="font-medium">${key}</div> <div class="flex items-center"> <button class="text-gray-500 hover:text-red-500 delete-knowledge-btn" data-category="${category}" data-key="${key}"> <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor"> <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16" /> </svg> </button> </div> </div> <div class="knowledge-item-content"> ${isArray ? content.map((item, index) => `<div class="flex justify-between items-center mb-1"> <div>${item}</div> <button class="text-gray-500 hover:text-red-500 delete-knowledge-btn" data-category="${category}" data-key="${key}" data-index="${index}"> <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor"> <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" /> </svg> </button> </div>` ).join('') : content} </div> `; knowledgeList.appendChild(itemDiv); } } function displayArrayItems(category, title) { const items = spurAIData[category]; if (items.length === 0) { return; } const categoryHeader = document.createElement('div'); categoryHeader.className = 'font-bold text-lg mt-4 mb-2'; categoryHeader.textContent = title; knowledgeList.appendChild(categoryHeader); items.forEach((item, index) => { const itemDiv = document.createElement('div'); itemDiv.className = 'knowledge-item'; itemDiv.innerHTML = ` <div class="flex justify-between items-center"> <div>${item}</div> <button class="text-gray-500 hover:text-red-500 delete-knowledge-btn" data-category="${category}" data-index="${index}"> <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor"> <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16" /> </svg> </button> </div> `; knowledgeList.appendChild(itemDiv); }); } function deleteKnowledgeItem(category, key, index) { if (confirm('Are you sure you want to delete this item?')) { if (index !== undefined) { // Delete array item if (key) { // Delete from nested array (responses) spurAIData[category][key].splice(index, 1); // Remove the key if the array is empty if (spurAIData[category][key].length === 0) { delete spurAIData[category][key]; } } else { // Delete from simple array (greetings, fallback) spurAIData[category].splice(index, 1); } } else { // Delete object key delete spurAIData[category][key]; } // Save to localStorage saveSpurData(); // Refresh display displayKnowledgeBase(); } } // Initialize by showing the category fields correctly handleCategoryChange(); });





